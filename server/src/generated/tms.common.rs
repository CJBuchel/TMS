// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Timestamp {
    /// Seconds since the Unix epoch.
    #[prost(int64, tag = "1")]
    pub seconds: i64,
    /// Nanoseconds since the Unix epoch.
    #[prost(int32, tag = "2")]
    pub nanos: i32,
}
/// Represents a date (year, month, day)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TmsDate {
    /// Year (e.g., 2024)
    #[prost(int32, tag = "1")]
    pub year: i32,
    /// Month (1-12)
    #[prost(int32, tag = "2")]
    pub month: i32,
    /// Day (1-31)
    #[prost(int32, tag = "3")]
    pub day: i32,
}
/// Represents a time of day
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TmsTime {
    /// Hour (0-23)
    #[prost(uint32, tag = "1")]
    pub hour: u32,
    /// Minute (0-59)
    #[prost(uint32, tag = "2")]
    pub minute: u32,
    /// Second (0-59)
    #[prost(uint32, tag = "3")]
    pub second: u32,
}
/// Represents a date and/or time
/// Can contain just date, just time, or both
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TmsDateTime {
    #[prost(message, optional, tag = "1")]
    pub date: ::core::option::Option<TmsDate>,
    #[prost(message, optional, tag = "2")]
    pub time: ::core::option::Option<TmsTime>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntegrityContext {
    #[prost(string, repeated, tag = "1")]
    pub context_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub team_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub match_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub session_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub pod_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntegrityMessage {
    #[prost(enumeration = "IntegrityCode", tag = "1")]
    pub code: i32,
    #[prost(enumeration = "IntegritySeverity", tag = "2")]
    pub severity: i32,
    #[prost(message, optional, tag = "3")]
    pub context: ::core::option::Option<IntegrityContext>,
    #[prost(string, tag = "4")]
    pub formatted_message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Role {
    Admin = 0,
    Referee = 1,
    HeadReferee = 2,
    Judge = 3,
    JudgeAdvisor = 4,
    ScoreKeeper = 5,
    Emcee = 6,
    Av = 7,
}
impl Role {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Admin => "ADMIN",
            Self::Referee => "REFEREE",
            Self::HeadReferee => "HEAD_REFEREE",
            Self::Judge => "JUDGE",
            Self::JudgeAdvisor => "JUDGE_ADVISOR",
            Self::ScoreKeeper => "SCORE_KEEPER",
            Self::Emcee => "EMCEE",
            Self::Av => "AV",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADMIN" => Some(Self::Admin),
            "REFEREE" => Some(Self::Referee),
            "HEAD_REFEREE" => Some(Self::HeadReferee),
            "JUDGE" => Some(Self::Judge),
            "JUDGE_ADVISOR" => Some(Self::JudgeAdvisor),
            "SCORE_KEEPER" => Some(Self::ScoreKeeper),
            "EMCEE" => Some(Self::Emcee),
            "AV" => Some(Self::Av),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntegrityCode {
    /// Errors
    E000 = 0,
    E001 = 1,
    E002 = 2,
    E003 = 3,
    E004 = 4,
    E005 = 5,
    E006 = 6,
    E007 = 7,
    E008 = 8,
    E009 = 9,
    E010 = 10,
    E011 = 11,
    E012 = 12,
    E013 = 13,
    /// Warnings - starts at 1000 for future
    W000 = 1000,
    W001 = 1001,
    W002 = 1002,
    W003 = 1003,
    W004 = 1004,
    W005 = 1005,
    W006 = 1006,
    W007 = 1007,
    W008 = 1008,
    W009 = 1009,
    W010 = 1010,
    W011 = 1011,
    W012 = 1012,
    W013 = 1013,
    W014 = 1014,
    W015 = 1015,
    W016 = 1016,
    W017 = 1017,
    W018 = 1018,
}
impl IntegrityCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::E000 => "E000",
            Self::E001 => "E001",
            Self::E002 => "E002",
            Self::E003 => "E003",
            Self::E004 => "E004",
            Self::E005 => "E005",
            Self::E006 => "E006",
            Self::E007 => "E007",
            Self::E008 => "E008",
            Self::E009 => "E009",
            Self::E010 => "E010",
            Self::E011 => "E011",
            Self::E012 => "E012",
            Self::E013 => "E013",
            Self::W000 => "W000",
            Self::W001 => "W001",
            Self::W002 => "W002",
            Self::W003 => "W003",
            Self::W004 => "W004",
            Self::W005 => "W005",
            Self::W006 => "W006",
            Self::W007 => "W007",
            Self::W008 => "W008",
            Self::W009 => "W009",
            Self::W010 => "W010",
            Self::W011 => "W011",
            Self::W012 => "W012",
            Self::W013 => "W013",
            Self::W014 => "W014",
            Self::W015 => "W015",
            Self::W016 => "W016",
            Self::W017 => "W017",
            Self::W018 => "W018",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "E000" => Some(Self::E000),
            "E001" => Some(Self::E001),
            "E002" => Some(Self::E002),
            "E003" => Some(Self::E003),
            "E004" => Some(Self::E004),
            "E005" => Some(Self::E005),
            "E006" => Some(Self::E006),
            "E007" => Some(Self::E007),
            "E008" => Some(Self::E008),
            "E009" => Some(Self::E009),
            "E010" => Some(Self::E010),
            "E011" => Some(Self::E011),
            "E012" => Some(Self::E012),
            "E013" => Some(Self::E013),
            "W000" => Some(Self::W000),
            "W001" => Some(Self::W001),
            "W002" => Some(Self::W002),
            "W003" => Some(Self::W003),
            "W004" => Some(Self::W004),
            "W005" => Some(Self::W005),
            "W006" => Some(Self::W006),
            "W007" => Some(Self::W007),
            "W008" => Some(Self::W008),
            "W009" => Some(Self::W009),
            "W010" => Some(Self::W010),
            "W011" => Some(Self::W011),
            "W012" => Some(Self::W012),
            "W013" => Some(Self::W013),
            "W014" => Some(Self::W014),
            "W015" => Some(Self::W015),
            "W016" => Some(Self::W016),
            "W017" => Some(Self::W017),
            "W018" => Some(Self::W018),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntegritySeverity {
    Unspecified = 0,
    Error = 1,
    Warning = 2,
}
impl IntegritySeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::Error => "ERROR",
            Self::Warning => "WARNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR" => Some(Self::Error),
            "WARNING" => Some(Self::Warning),
            _ => None,
        }
    }
}
